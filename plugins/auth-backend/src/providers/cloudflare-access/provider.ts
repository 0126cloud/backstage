/*
 * Copyright 2022 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import {
  AuthHandler,
  AuthProviderRouteHandlers,
  AuthResolverContext,
  AuthResponse,
  SignInResolver,
} from '../types';
import express from 'express';
import * as _ from 'lodash';
import { jwtVerify, createRemoteJWKSet } from 'jose';
import { Profile as PassportProfile } from 'passport';
import { AuthenticationError } from '@backstage/errors';
import { createAuthProviderIntegration } from '../createAuthProviderIntegration';
import { prepareBackstageIdentityResponse } from '../prepareBackstageIdentityResponse';
import { makeProfileInfo } from '../../lib/passport';

// JWT Web Token definitions are in the URL below
// https://developers.cloudflare.com/cloudflare-one/identity/users/validating-json/
export const CF_JWT_HEADER = 'cf-access-jwt-assertion';
export const CF_AUTH_IDENTITY = 'cf-access-authenticated-user-email';

/** @public */
export type Options = {
  /**
   * Access team name
   *
   * When you configure Access, the public certificates are available at this
   * URL, where your-team-name is your team name:
   * https://<your-team-name>.cloudflareaccess.com/cdn-cgi/access/certs
   */
  teamName: string;
  authHandler: AuthHandler<CloudflareAccessResult>;
  signInResolver: SignInResolver<CloudflareAccessResult>;
  resolverContext: AuthResolverContext;
};

/** @public */
export type CloudflareAccessClaims = {
  /**
   * `aud` identifies the application to which the JWT is issued.
   */
  aud: string[];
  /**
   * `email` contains the email address of the authenticated user.
   */
  email: string;
  /**
   * iat and exp are the issuance and expiration timestamps.
   */
  exp: number;
  iat: number;
  /**
   * `nonce` is the session identifier.
   */
  nonce: string;
  /**
   * `identity_nonce` is available in the Application Token and can be used to
   * query all group membership for a given user.
   */
  identity_nonce: string;
  /**
   * `sub` contains the identifier of the authenticated user.
   */
  sub: string;
  /**
   * `iss` the issuer is the applicationâ€™s Cloudflare Access Domain URL.
   */
  iss: string;
  /**
   * `custom` contains SAML attributes in the Application Token specified by an
   * administrator in the identity provider configuration.
   */
  custom: string;
};

/** @public */
export type CloudflareAccessResult = {
  fullProfile: PassportProfile;
  expiresInSeconds?: number;
};

export type CloudflareAccessProviderInfo = {
  /**
   * Expiry of the access token in seconds.
   */
  expiresInSeconds?: number;
};

export type CloudflareAccessResponse =
  AuthResponse<CloudflareAccessProviderInfo>;

export class CloudflareAccessAuthProvider implements AuthProviderRouteHandlers {
  private readonly teamName: string;
  private readonly resolverContext: AuthResolverContext;
  private readonly authHandler: AuthHandler<CloudflareAccessResult>;
  private readonly signInResolver: SignInResolver<CloudflareAccessResult>;
  private readonly jwtKeySet: any;

  constructor(options: Options) {
    this.teamName = options.teamName;
    this.authHandler = options.authHandler;
    this.signInResolver = options.signInResolver;
    this.resolverContext = options.resolverContext;
    this.jwtKeySet = createRemoteJWKSet(
      new URL(
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/certs`,
      ),
    );
  }

  frameHandler(): Promise<void> {
    return Promise.resolve();
  }

  async refresh(req: express.Request, res: express.Response): Promise<void> {
    // ProxiedSignInPage calls `/refresh` implicitly each time the backstage
    // app is refreshed on the browser.
    // User authentication is then checked here.
    const result = await this.getResult(req);
    const response = await this.handleResult(result);
    res.json(response);
  }

  start(): Promise<void> {
    return Promise.resolve();
  }

  private async getResult(
    req: express.Request,
  ): Promise<CloudflareAccessResult> {
    // JWTs generated by Access are available in a request header as
    // Cf-Access-Jwt-Assertion and as cookies as CF_Authorization.
    let jwt = req.header(CF_JWT_HEADER);
    if (!jwt) {
      jwt = req.cookies.CF_Authorization;
    }
    if (!jwt) {
      // Only throw if both are not provided by Cloudflare Access since either
      // can be used.
      throw new AuthenticationError(
        `Missing ${CF_JWT_HEADER} from Cloudflare Access`,
      );
    }

    // Cloudflare signs the JWT using the RSA Signature with SHA-256 (RS256).
    // RS256 follows an asymmetric algorithm; a private key signs the JWTs and
    // a separate public key verifies the signature.
    const verifyResult = await jwtVerify(jwt, this.jwtKeySet, {
      // Cloudflare signs the JWT using the RSA Signature with SHA-256 (RS256).
      algorithms: ['RS256'],
      issuer: `https://${this.teamName}.cloudflareaccess.com`,
    });
    const claims = verifyResult.payload as CloudflareAccessClaims;

    const fullProfile: PassportProfile = {
      provider: 'cfAccess',
      id: claims.sub,
      displayName: _.startCase(
        claims.email.split('@')[0].toLowerCase().replace('.', ' '),
      ),
      username: claims.email.split('@')[0].toLowerCase(),
      emails: [{ value: claims.email.toLowerCase() }],
    };

    return {
      fullProfile,
      expiresInSeconds: claims.exp - claims.iat,
    };
  }

  private async handleResult(
    result: CloudflareAccessResult,
  ): Promise<CloudflareAccessResponse> {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const backstageIdentity = await this.signInResolver(
      {
        result,
        profile,
      },
      this.resolverContext,
    );

    return {
      providerInfo: {
        expiresInSeconds: result.expiresInSeconds,
      },
      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),
      profile,
    };
  }
}

/**
 * Auth provider integration for Cloudflare Access auth
 *
 * @public
 */
export const cfAccess = createAuthProviderIntegration({
  create(options?: {
    /**
     * The profile transformation function used to verify and convert the auth response
     * into the profile that will be presented to the user.
     */
    authHandler?: AuthHandler<CloudflareAccessResult>;

    /**
     * Configure sign-in for this provider, without it the provider can not be used to sign users in.
     */
    signIn: {
      /**
       * Maps an auth result to a Backstage identity for the user.
       */
      resolver: SignInResolver<CloudflareAccessResult>;
    };
  }) {
    return ({ config, resolverContext }) => {
      const teamName = config.getString('teamName');

      if (!options?.signIn.resolver) {
        throw new Error(
          'SignInResolver is required to use this authentication provider',
        );
      }

      const authHandler: AuthHandler<CloudflareAccessResult> =
        options?.authHandler
          ? options.authHandler
          : async ({ fullProfile }) => ({
              profile: makeProfileInfo(fullProfile),
            });

      return new CloudflareAccessAuthProvider({
        teamName,
        signInResolver: options?.signIn.resolver,
        authHandler,
        resolverContext,
      });
    };
  },
});
