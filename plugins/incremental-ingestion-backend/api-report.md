## API Report File for "@backstage/plugin-incremental-ingestion-backend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CatalogBuilder } from '@backstage/plugin-catalog-backend';
import type { Config } from '@backstage/config';
import type { DeferredEntity } from '@backstage/plugin-catalog-backend';
import { Duration } from 'luxon';
import type { DurationObjectUnits } from 'luxon';
import type { EntityProviderConnection } from '@backstage/plugin-catalog-backend';
import { Knex } from 'knex';
import type { Logger } from 'winston';
import type { PermissionAuthorizer } from '@backstage/plugin-permission-common';
import type { PluginDatabaseManager } from '@backstage/backend-common';
import type { PluginTaskScheduler } from '@backstage/backend-tasks';
import { Router } from 'express';
import type { TaskFunction } from '@backstage/backend-tasks';
import type { UrlReader } from '@backstage/backend-common';

// @public
export interface EntityIteratorResult<T> {
  cursor: T;
  done: boolean;
  entities: DeferredEntity[];
}

// @public
export const INCREMENTAL_ENTITY_PROVIDER_ANNOTATION =
  'backstage.io/incremental-provider-name';

// @public (undocumented)
export class IncrementalCatalogBuilder {
  // (undocumented)
  addIncrementalEntityProvider<T, C>(
    provider: IncrementalEntityProvider<T, C>,
    options: IncrementalEntityProviderOptions,
  ): void;
  // (undocumented)
  build(): Promise<{
    incrementalAdminRouter: Router;
    manager: IncrementalIngestionDatabaseManager;
  }>;
  static create(
    env: PluginEnvironment,
    builder: CatalogBuilder,
  ): Promise<IncrementalCatalogBuilder>;
}

// @public
export interface IncrementalEntityProvider<TCursor, TContext> {
  around(burst: (context: TContext) => Promise<void>): Promise<void>;
  getProviderName(): string;
  next(
    context: TContext,
    cursor?: TCursor,
  ): Promise<EntityIteratorResult<TCursor>>;
}

// @public (undocumented)
export interface IncrementalEntityProviderOptions {
  backoff?: DurationObjectUnits[];
  burstInterval: DurationObjectUnits;
  burstLength: DurationObjectUnits;
  restLength: DurationObjectUnits;
}

// @public (undocumented)
export class IncrementalIngestionDatabaseManager {
  constructor(options: { client: Knex });
  cleanupProviders(): Promise<{
    ingestionsDeleted: void;
    ingestionMarksDeleted: void;
    markEntitiesDeleted: void;
  }>;
  clearDuplicateIngestions(
    ingestionId: string,
    provider: string,
  ): Promise<void>;
  clearFinishedIngestions(provider: string): Promise<{
    deletions: {
      markEntitiesDeleted: number;
      marksDeleted: number;
      ingestionsDeleted: number;
    };
  }>;
  computeRemoved(
    provider: string,
    ingestionId: string,
  ): Promise<
    {
      entity: any;
    }[]
  >;
  createMark(options: MarkRecordInsert): Promise<void>;
  createMarkEntities(markId: string, entities: DeferredEntity[]): Promise<void>;
  createProviderIngestionRecord(provider: string): Promise<{
    ingestionId: string;
    nextAction: string;
    attempts: number;
    nextActionAt: number;
  }>;
  // (undocumented)
  getAllMarks(ingestionId: string): Promise<MarkRecord[]>;
  getCurrentIngestionRecord(
    provider: string,
  ): Promise<IngestionRecord | undefined>;
  getLastMark(ingestionId: string): Promise<MarkRecord | undefined>;
  healthcheck(): Promise<
    Pick<
      {
        id: string;
        provider_name: string;
      },
      'id' | 'provider_name'
    >[]
  >;
  insertIngestionRecord(options: IngestionRecordInsert): Promise<void>;
  // (undocumented)
  insertRecord(options: IngestionRecordInsert): Promise<void>;
  listProviders(): Promise<string[]>;
  purgeAndResetProvider(provider: string): Promise<{
    provider: string;
    ingestionsDeleted: number;
    marksDeleted: number;
    markEntitiesDeleted: number;
  }>;
  purgeTable(table: string): Promise<void>;
  setProviderBackoff(
    ingestionId: string,
    attempts: number,
    error: Error,
    backoffLength: number,
  ): Promise<void>;
  setProviderBursting(ingestionId: string): Promise<void>;
  setProviderCanceled(ingestionId: string): Promise<void>;
  setProviderCanceling(ingestionId: string, message?: string): Promise<void>;
  setProviderComplete(ingestionId: string): Promise<void>;
  setProviderIngesting(ingestionId: string): Promise<void>;
  setProviderInterstitial(ingestionId: string): Promise<void>;
  setProviderResting(ingestionId: string, restLength: Duration): Promise<void>;
  triggerNextProviderAction(provider: string): Promise<void>;
  // (undocumented)
  updateByName(
    provider: string,
    update: Partial<IngestionUpsertIFace>,
  ): Promise<void>;
  updateIngestionRecordById(options: IngestionRecordUpdate): Promise<void>;
  updateIngestionRecordByProvider(
    provider: string,
    update: Partial<IngestionUpsertIFace>,
  ): Promise<void>;
}

// @public
export interface IngestionRecord {
  // (undocumented)
  attempts: number;
  // (undocumented)
  created_at: string;
  // (undocumented)
  id: string;
  // (undocumented)
  ingestion_completed_at: string | null;
  // (undocumented)
  last_error: string | null;
  // (undocumented)
  next_action: string;
  // (undocumented)
  next_action_at: Date;
  // (undocumented)
  provider_name: string;
  // (undocumented)
  rest_completed_at: string | null;
  // (undocumented)
  status: string;
}

// @public
export interface IngestionRecordInsert {
  // (undocumented)
  record: IngestionUpsertIFace & {
    id: string;
  };
}

// @public
export interface IngestionRecordUpdate {
  // (undocumented)
  ingestionId: string;
  // (undocumented)
  update: Partial<IngestionUpsertIFace>;
}

// @public
export interface IngestionUpsertIFace {
  // (undocumented)
  attempts?: number;
  // (undocumented)
  ingestion_completed_at?: Date;
  // (undocumented)
  last_error?: string;
  // (undocumented)
  next_action:
    | 'rest'
    | 'ingest'
    | 'backoff'
    | 'cancel'
    | 'nothing (done)'
    | 'nothing (canceled)';
  // (undocumented)
  next_action_at?: Date;
  // (undocumented)
  provider_name: string;
  // (undocumented)
  rest_completed_at?: Date;
  // (undocumented)
  status:
    | 'complete'
    | 'bursting'
    | 'resting'
    | 'canceling'
    | 'interstitial'
    | 'backing off';
}

// @public
export interface IterationEngine {
  // (undocumented)
  taskFn: TaskFunction;
}

// @public
export interface IterationEngineOptions {
  // (undocumented)
  backoff?: IncrementalEntityProviderOptions['backoff'];
  // (undocumented)
  connection: EntityProviderConnection;
  // (undocumented)
  logger: Logger;
  // (undocumented)
  manager: IncrementalIngestionDatabaseManager;
  // (undocumented)
  provider: IncrementalEntityProvider<unknown, unknown>;
  // (undocumented)
  ready: Promise<void>;
  // (undocumented)
  restLength: DurationObjectUnits;
}

// @public
export interface MarkRecord {
  // (undocumented)
  created_at: string;
  // (undocumented)
  cursor: string;
  // (undocumented)
  id: string;
  // (undocumented)
  ingestion_id: string;
  // (undocumented)
  sequence: number;
}

// @public
export interface MarkRecordInsert {
  // (undocumented)
  record: {
    id: string;
    ingestion_id: string;
    cursor: unknown;
    sequence: number;
  };
}

// @public
export type PluginEnvironment = {
  logger: Logger;
  database: PluginDatabaseManager;
  scheduler: PluginTaskScheduler;
  config: Config;
  reader: UrlReader;
  permissions: PermissionAuthorizer;
};

// (No @packageDocumentation comment for this package)
```
